IMPLEMENT POSITION RECALCULATION WHEN CUSTOMERS FINISH/CANCEL

REQUIREMENT:
When a customer is finished or cancelled, all remaining active customers should have their activeQueuePosition recalculated to show accurate waiting position.

EXAMPLE SCENARIO:
Initial state:
- Customer A: dailySerialNumber=1, activeQueuePosition=1, status="waiting"
- Customer B: dailySerialNumber=2, activeQueuePosition=2, status="waiting"  
- Customer C: dailySerialNumber=3, activeQueuePosition=3, status="waiting"

After Customer A finishes:
- Customer A: dailySerialNumber=1, activeQueuePosition=1, status="completed"
- Customer B: dailySerialNumber=2, activeQueuePosition=1 (updated from 2), status="waiting"
- Customer C: dailySerialNumber=3, activeQueuePosition=2 (updated from 3), status="waiting"

Note: dailySerialNumber NEVER changes, only activeQueuePosition updates


IMPLEMENTATION:

Create a function to recalculate active queue positions:
```javascript
async function recalculateActiveQueuePositions(bookingDate) {
  // Get all active bookings for the date, sorted by original serial number
  const activeBookings = await Booking.find({
    bookingDate: bookingDate,
    status: { $in: ["waiting", "called", "confirmed"] }
  }).sort({ dailySerialNumber: 1 });  // Sort by original booking order
  
  // Reassign positions sequentially: 1, 2, 3, 4...
  for (let i = 0; i < activeBookings.length; i++) {
    await Booking.updateOne(
      { _id: activeBookings[i]._id },
      { 
        activeQueuePosition: i + 1,
        updatedAt: new Date()
      }
    );
  }
  
  return activeBookings.length;  // Return count of active bookings
}
```


CALL THIS FUNCTION AFTER:

1. Finish Button Click:
```javascript
// In your finish button handler
async function handleFinish(bookingId) {
  // Get the booking to find its date
  const booking = await Booking.findById(bookingId);
  
  // Update status to completed
  await Booking.updateOne(
    { _id: bookingId },
    { 
      status: "completed",
      updatedAt: new Date()
    }
  );
  
  // Recalculate positions for remaining customers
  await recalculateActiveQueuePositions(booking.bookingDate);
  
  console.log(`Customer ${booking.name} finished. Positions recalculated.`);
}
```

2. Cancel Button Click:
```javascript
// In your cancel button handler
async function handleCancel(bookingId) {
  // Get the booking to find its date
  const booking = await Booking.findById(bookingId);
  
  // Update status to cancelled
  await Booking.updateOne(
    { _id: bookingId },
    { 
      status: "cancelled",
      updatedAt: new Date()
    }
  );
  
  // Recalculate positions for remaining customers
  await recalculateActiveQueuePositions(booking.bookingDate);
  
  console.log(`Customer ${booking.name} cancelled. Positions recalculated.`);
}
```

3. Call Now Button (NO recalculation needed):
```javascript
// In your call now button handler
async function handleCallNow(bookingId) {
  // Update status to called
  await Booking.updateOne(
    { _id: bookingId },
    { 
      status: "called",
      calledAt: new Date(),
      updatedAt: new Date()
    }
  );
  
  // NO recalculation needed - customer still in active queue
}
```

4. Confirm Button (NO recalculation needed):
```javascript
// In your confirm button handler  
async function handleConfirm(bookingId) {
  // Update status to confirmed
  await Booking.updateOne(
    { _id: bookingId },
    { 
      status: "confirmed",
      respondedAt: new Date(),
      updatedAt: new Date()
    }
  );
  
  // NO recalculation needed - customer still in active queue
}
```


CRITICAL RULES:
- dailySerialNumber: NEVER changes after creation (permanent tracking number)
- activeQueuePosition: ALWAYS recalculated when active queue changes
- Only customers with status "waiting", "called", or "confirmed" are in active queue
- Customers with status "completed" or "cancelled" are removed from active queue
- Recalculation sorts by dailySerialNumber to preserve original booking order


TESTING AFTER IMPLEMENTATION:

Test Scenario 1: Finish first customer
1. Create 5 bookings (positions 1, 2, 3, 4, 5)
2. Finish customer with position 1
3. Verify remaining customers now have positions 1, 2, 3, 4
4. Verify their dailySerialNumber remains 2, 3, 4, 5

Test Scenario 2: Finish middle customer
1. Create 5 bookings (positions 1, 2, 3, 4, 5)
2. Finish customer with position 3
3. Verify positions are now 1, 2, 3, 4 (for customers with serial 1, 2, 4, 5)

Test Scenario 3: Multiple finishes
1. Create 5 bookings
2. Finish customer 1 → positions become 1, 2, 3, 4
3. Finish customer 2 → positions become 1, 2, 3
4. Finish customer 5 → positions become 1, 2
5. Verify only 2 active customers remain with positions 1, 2


BACKEND RESPONSE (Optional but helpful):
After recalculation, you can return updated data to frontend:
```javascript
async function handleFinish(bookingId) {
  const booking = await Booking.findById(bookingId);
  
  await Booking.updateOne(
    { _id: bookingId },
    { status: "completed", updatedAt: new Date() }
  );
  
  const activeCount = await recalculateActiveQueuePositions(booking.bookingDate);
  
  // Return success response
  return {
    success: true,
    message: `Customer finished. ${activeCount} customers remaining.`,
    activeCount: activeCount
  };
}
```


REAL-TIME UPDATES (If using WebSockets/Socket.io):
After recalculation, emit event to update customer queue cards:
```javascript
// After recalculation
const updatedBookings = await Booking.find({
  bookingDate: booking.bookingDate,
  status: { $in: ["waiting", "called", "confirmed"] }
});

// Emit to all connected customers
updatedBookings.forEach(b => {
  io.to(b._id.toString()).emit('positionUpdated', {
    newPosition: b.activeQueuePosition
  });
});
```


VERIFICATION QUERY:
After implementing, run this to verify recalculation works:
```javascript
// Check active bookings have sequential positions
const activeBookings = await Booking.find({
  bookingDate: new Date("2026-02-10T00:00:00.000Z"),
  status: { $in: ["waiting", "called", "confirmed"] }
}).sort({ activeQueuePosition: 1 });

console.log(activeBookings.map(b => ({
  name: b.name,
  serial: b.dailySerialNumber,
  position: b.activeQueuePosition
})));

// Expected output: positions should be 1, 2, 3, 4... (sequential)
// serials can be any numbers like 33, 34, 36, 38... (with gaps)
```


EDGE CASES TO HANDLE:

1. Last customer finishes:
   - activeQueuePosition recalculation runs
   - Returns 0 active customers
   - No errors

2. Customer already completed:
   - Check status before allowing finish
   - Prevent duplicate finish actions

3. Same customer finished twice:
   - Status check prevents this
   - Or use idempotent operations


Please implement this recalculation logic and integrate it with all status change buttons (Finish and Cancel only).